# BLS Digital Signatures と Ethereum PoS（Beacon Chain）で使う意味

このノートでは、Ethereum の PoS（Beacon Chain）で採用されている **BLS（Boneh–Lynn–Shacham）署名**の狙いと仕組みを、数式（LaTeX）つきで整理します。

---

## 0. 数学が苦手な方向け：ここだけ先に読む（超やさしい導入）

### 0.1 「mod（モジュロ）」＝“余りで同一視する” という約束

例えば **mod 7** の世界では、整数を 7 で割った余りだけを気にします。

- \(15 \bmod 7 = 1\)（15 を 7 で割ると余り 1）
- \(-1 \bmod 7 = 6\)（\(-1\) は 7 を足すと 6 と同じ扱い）

この世界では、次のように「同じもの」と見なします：

\[
15 \equiv 1 \pmod 7,\quad -1 \equiv 6 \pmod 7
\]

直感としては、**数直線を 7 ごとにぐるっと丸めた“時計”**を想像すると分かりやすいです。

### 0.2 「有限体 \( \mathbb{F}_q \)」＝“mod \(q\)”で四則演算ができる箱

**\( \mathbb{F}_q \)** は「\(q\) を法にした世界（mod \(q\)）」で、足し算・引き算・掛け算・割り算（※0 で割るのは除く）がきちんとできるように作ったものです。

- \(q\) が **素数**なら、だいたい「整数を mod \(q\) にした世界」そのものが \( \mathbb{F}_q \) になります。
- ここで **“割り算ができる”**というのは、「\(a \ne 0\) なら逆数 \(a^{-1}\) が存在して \(a\cdot a^{-1} \equiv 1 \pmod q\)」という意味です。

例：mod 7 なら、\(3^{-1} \equiv 5\)（なぜなら \(3\cdot 5 = 15 \equiv 1 \pmod 7\)）。

### 0.3 楕円曲線暗号の “点” は「足し算できるオブジェクト」

楕円曲線暗号では、点 \(P\) を「足し算できる記号」だと思ってください。

- \(P + P\) を \(2P\) と書く
- \(P\) を \(x\) 回足したものを \(xP\) と書く（スカラー倍）

重要なのは **\(xP\) は計算しやすい**けど、逆に **\(P\) と \(xP\) から \(x\) を当てるのは難しい**、という片方向性です（これが暗号の硬さの元）。

### 0.4 BLS の“気持ち”は「署名＝秘密鍵で点をスカラー倍」

BLS 署名はざっくり言うと：

- メッセージ \(m\) を “点” に変換して \(H(m)\) を作る
- 秘密鍵 \(x\) でスカラー倍して \(\sigma = xH(m)\) を作る

検証はペアリング \(e(\cdot,\cdot)\) を使って、
「\(\sigma\) が本当に \(xH(m)\) になっているか」を **秘密鍵 \(x\) を知らなくても**確かめられる、という仕組みです。

### 0.5 Ethereum PoS で BLS が刺さる理由（超要点）

PoS では「同じ内容に、多人数が同時に署名」する場面（投票/同意）が多いです。BLS は署名を

\[
\sigma_{\mathrm{agg}} = \sigma_1 + \sigma_2 + \cdots + \sigma_n
\]

のように足して **1 本にまとめられる（集約できる）**のが強みです。

---

## 1. まず結論：Ethereum PoS で BLS を使う「意味」

Ethereum PoS が BLS を使う最大の理由は、**多数のバリデータ署名を 1 本の署名に「集約（aggregate）」できる**ことです。

- **帯域削減**: ブロックに含める署名データが小さくなる  
- **検証コスト削減**: 多数署名の検証をまとめて（特に同一メッセージなら）効率化できる  
- **プロトコル設計と相性が良い**: attestation / sync committee など「多人数が同時に署名する」場面が多い

対照的に、Ethereum の実行レイヤ（トランザクション署名）の主流である ECDSA は、**一般には “多数署名→1本” のネイティブ集約ができない**ため、PoS の「大量署名」には不利です。

---

## 2. 前提：群・離散対数・署名の見取り図

### 2.0 ここでの記号の読み方（つまずきやすい所）

- \( \mathbb{Z}_p \): \(p\) で割った余りの集合（0〜\(p-1\)）だと思って OK（ここでは \(p\) は素数の想定）
- \(x \leftarrow \mathbb{Z}_p\): 「\(x\) を 0〜\(p-1\) からランダムに選ぶ」
- \(X = xg\): 「\(g\) を \(x\) 回足す」イメージ（楕円曲線では “点のスカラー倍”）

### 2.1 離散対数問題（DLP）

位数 \(p\) の（加法）巡回群 \(G\) と生成元 \(g\) を考えます。

- 秘密鍵: \(x \in \mathbb{Z}_p\)
- 公開鍵: \(X = xg \in G\)

**離散対数問題（DLP）**は、\(g\) と \(X=xg\) から \(x\) を求めるのが困難、という仮定です。

---

## 3. BLS 署名の仕組み（ペアリング）

### 3.0 そもそも「ペアリング」って何のため？

ペアリング \(e(\cdot,\cdot)\) を雑に言うと、**2つの"点"を入れると、第三の世界（\(G_T\)）の値が出てくる関数**です。

そして重要なのが **双線形性（bilinear）**で、これは「指数（スカラー）がうまく外に出てくる」性質です：

\[
e(aP, Q) = e(P, Q)^a,\quad e(P, bQ) = e(P, Q)^b
\]

さらに、**足し算が掛け算に写る**という双線形性もあります：

\[
e(P_1+P_2, Q) = e(P_1, Q) \cdot e(P_2, Q)
\]
\[
e(P, Q_1+Q_2) = e(P, Q_1) \cdot e(P, Q_2)
\]

この性質があるから、BLS の検証
\[
e(g_1, \sigma) \stackrel{?}{=} e(pk, H(m))
\]
が成立します（後で出てくる通り、両辺とも \(e(g_1, H(m))^x\) に揃う）。

### 3.0.1 なぜ BLS12-381 で双線形性 \(e(P_1+P_2,Q)=e(P_1,Q)e(P_2,Q)\) が成立するのか

この性質は BLS 署名の集約において**最も重要**な性質です。ここでは、なぜこの等式が成り立つのかを、数学的背景から説明します。

#### 直感的な理解：「点の足し算」が「ターゲット群の掛け算」に写る

まず、ペアリングは次のような準同型写像（homomorphism）です：

- **入力側（\(G_1, G_2\)）**: 演算は「点の足し算」
- **出力側（\(G_T\)）**: 演算は「掛け算」

準同型性とは、「演算を保つ」という意味です。つまり：

\[
e(\text{足し算}, \cdot) = \text{掛け算}
\]

具体的には、\(P_1, P_2 \in G_1\) と \(Q \in G_2\) について：

\[
e(P_1+P_2, Q) = e(P_1, Q) \cdot e(P_2, Q)
\]

が成り立つように \(e\) が設計されています。

#### BLS12-381 における実装：Ate ペアリングと Miller アルゴリズム

BLS12-381 では、ペアリングは **Ate ペアリング**（または Tate ペアリングの変種）として実装されます。

ペアリングの計算は、概ね次の2ステップで行われます：

1. **Miller ループ**：楕円曲線上の"直線"や"接線"を使って、有理関数を構築する
2. **最終べき乗**：結果を \(\mathbb{F}_{q^{12}}\) の特定の部分群に持ち上げる

この過程で、**双線形性が保たれる**ように設計されています。

#### なぜ双線形性が保たれるのか（数学的概略）

双線形性が成り立つ理由は、ペアリングの定義に由来します。

BLS12-381 の Ate ペアリングは、次のような **Weil ペアリング**や **Tate ペアリング**を効率化したものです。

まず、簡略化した Tate ペアリングの定義を考えます：

\[
e(P, Q) = f_{r,P}(Q)^{(q^k-1)/r}
\]

ここで：
- \(f_{r,P}\) は、点 \(P\) に関連する有理関数（Miller の構築法で作られる）
- \(k\) は埋め込み次数（BLS12-381 では \(k=12\)）
- \(r\) は群の位数

#### 双線形性の証明のポイント

**第一引数の加法性** \(e(P_1+P_2, Q) = e(P_1, Q) \cdot e(P_2, Q)\) が成り立つ理由：

有理関数の性質から、
\[
f_{r, P_1+P_2}(Q) = f_{r,P_1}(Q) \cdot f_{r,P_2}(Q) \cdot g(Q)
\]
という関係が成り立ちます（\(g\) は補正項）。

最終べき乗 \((q^k-1)/r\) を適用すると、補正項 \(g\) は消えて：
\[
e(P_1+P_2, Q) = \left(f_{r,P_1+P_2}(Q)\right)^{(q^k-1)/r} = \left(f_{r,P_1}(Q) \cdot f_{r,P_2}(Q)\right)^{(q^k-1)/r}
\]
\[
= \left(f_{r,P_1}(Q)\right)^{(q^k-1)/r} \cdot \left(f_{r,P_2}(Q)\right)^{(q^k-1)/r} = e(P_1,Q) \cdot e(P_2,Q)
\]

**第二引数の加法性** \(e(P, Q_1+Q_2) = e(P, Q_1) \cdot e(P, Q_2)\) も同様に成り立ちます。

#### スカラー倍に対する双線形性

スカラー倍 \(aP = \underbrace{P+P+\cdots+P}_{a\text{回}}\) を考えると、上の加法性を繰り返し適用して：

\[
e(aP, Q) = \underbrace{e(P,Q) \cdot e(P,Q) \cdots e(P,Q)}_{a\text{回}} = e(P,Q)^a
\]

同様に：
\[
e(P, bQ) = e(P,Q)^b
\]

そして、両方を組み合わせると：
\[
e(aP, bQ) = e(P,Q)^{ab}
\]

これが **双線形性**の核心です。

#### BLS 署名の集約がなぜ可能か（再確認）

この双線形性があるから、BLS の集約署名は次のように検証できます：

\[
e(g_1, \sigma_1 + \sigma_2 + \cdots + \sigma_n) = e(g_1, \sigma_1) \cdot e(g_1, \sigma_2) \cdots e(g_1, \sigma_n)
\]

各 \(\sigma_i = x_i H(m)\) なので：

\[
= e(g_1, H(m))^{x_1} \cdot e(g_1, H(m))^{x_2} \cdots e(g_1, H(m))^{x_n} = e(g_1, H(m))^{\sum x_i}
\]

一方で公開鍵の集約：

\[
e(pk_1 + pk_2 + \cdots + pk_n, H(m)) = e(g_1, H(m))^{\sum x_i}
\]

となり、両辺が一致します。

#### まとめ：BLS12-381 の双線形性

BLS12-381 のペアリング \(e\) は、**Ate ペアリング + Miller アルゴリズム**で実装され、その構成法により：

\[
e(P_1+P_2, Q) = e(P_1,Q) \cdot e(P_2,Q)
\]
\[
e(aP, bQ) = e(P,Q)^{ab}
\]

が**数学的に保証**されています。この性質こそが、BLS 署名の集約を可能にする基盤です。

### 3.1 ペアリングを使う群の設定

BLS は **双線形写像（pairing）** を使います。典型的には次の 3 つの群を使います。

- \(G_1, G_2\): 位数 \(p\) の巡回群
- \(G_T\): 位数 \(p\) の巡回群
- ペアリング:
  \[
    e: G_1 \times G_2 \to G_T
  \]

ペアリングの重要な性質（双線形性）は：
\[
  e(aP, bQ) = e(P, Q)^{ab}
\]
\[
  e(P_1+P_2, Q) = e(P_1, Q)\cdot e(P_2, Q)
\]
\[
  e(P, Q_1+Q_2) = e(P, Q_1)\cdot e(P, Q_2)
\]

Ethereum PoS では実装として **BLS12-381** を使います。BLS には「公開鍵を \(G_1\) に置くか \(G_2\) に置くか」などの **流儀の違い**がありますが、このノートは **あなたの流儀（公開鍵 \(pk \in G_1\)、署名 \(\sigma \in G_2\)）に統一**して説明します。

### 3.2 BLS の鍵生成・署名・検証（このノートの流儀：\(pk \in G_1\), \(\sigma \in G_2\)）

- **鍵生成**  
  秘密鍵（スカラー）: \(x \leftarrow \mathbb{F}_r\)（実装では通常 \(1 \le x \le r-1\)）  
  生成元 \(g_1 \in G_1\) を固定し、公開鍵は  
  \[
    pk = x g_1 \in G_1
  \]

- **署名**（メッセージ \(m\)）  
  ハッシュを曲線上の点に写像（hash-to-curve）して
  \[
    H: \{0,1\}^* \to G_2
  \]
  を用意する。  
  署名は
  \[
    \sigma = x \cdot H(m) \in G_2
  \]

- **検証**  
  \[
    e(g_1, \sigma) \stackrel{?}{=} e(pk, H(m))
  \]

**なぜ検証できるか（直感）**: 左辺は
\[
  e(g_1, xH(m)) = e(g_1, H(m))^x
\]
右辺は
\[
  e(xg_1, H(m)) = e(g_1, H(m))^x
\]
で一致します（双線形性）。

#### 3.2.1 「BLS は何がうれしい？」を一言で

BLS は **ペアリングの等式**で検証します。ここで “掛け算の指数（スカラー）” がきれいに揃うので、後述の **集約（足し算でまとめる）**がとても自然に実現できます。

### 3.3 検証式 `e(g1, \sigma) = e(pk, H(m))` を “一行ずつ” 解説

ここは混乱しやすいので、まず「どれがどの集合（群）に属するか」を固定します。

#### 3.3.1 どの群に何を置くか（2つの流儀がある）

ペアリングは

\[
e: G_1 \times G_2 \to G_T
\]

なので、**左の引数は \(G_1\)**、**右の引数は \(G_2\)** に置く必要があります。

このノートでは、以下の配置（あなたが確認した流儀）だけを使います。

- **このノートの流儀**  
  - 生成元 \(g_1 \in G_1\)  
  - 公開鍵 \(pk = xg_1 \in G_1\)  
  - ハッシュ \(H(m) \in G_2\)（メッセージを \(G_2\) の点へ写す）  
  - 署名 \(\sigma = xH(m) \in G_2\)

#### 3.3.2 まず前提：ペアリングの双線形性（これだけ使う）

\[
e(aP, Q) = e(P, Q)^a,\quad e(P, bQ) = e(P, Q)^b
\]

特に重要なのが次の“入れ替え”です：

\[
e(aP, Q) = e(P, aQ)
\]

（なぜなら両辺とも \(e(P,Q)^a\) だからです）

#### 3.3.3 検証式 `e(g1, \sigma) = e(pk, H(m))` が成り立つ理由

鍵と署名の定義をそのまま代入します。

- 秘密鍵（スカラー）: \(x \in \mathbb{F}_r\)（後で「なぜ mod \(r\) なのか」を説明します）
- 公開鍵: \(pk = xg_1\)
- 署名: \(\sigma = xH(m)\)

左辺：
\[
e(g_1, \sigma) = e(g_1, xH(m))
\]
双線形性より：
\[
e(g_1, xH(m)) = e(g_1, H(m))^x
\]

右辺：
\[
e(pk, H(m)) = e(xg_1, H(m))
\]
双線形性より：
\[
e(xg_1, H(m)) = e(g_1, H(m))^x
\]

左辺も右辺も **同じ \(e(g_1, H(m))^x\)** になるので、
\[
e(g_1, \sigma) = e(pk, H(m))
\]
が成り立ちます。これが BLS の「検証ができる理由」です。

---

## 4. BLS の本領：集約署名（Aggregate Signatures）

Ethereum PoS の「意味」はここに集約されています。

### 4.1 同一メッセージに対する集約（このノートの流儀）

複数の署名者 \(i=1..n\) が **同一メッセージ \(m\)** に署名する場合、BLS は署名を足し算して 1 本にまとめられます。

- 各公開鍵: \(pk_i = x_i g_1 \in G_1\)
- 各署名: \(\sigma_i = x_i H(m) \in G_2\)

署名を加算して
\[
  \sigma_{\mathrm{agg}} = \sum_{i=1}^n \sigma_i
\]
公開鍵も加算して
\[
  pk_{\mathrm{agg}} = \sum_{i=1}^n pk_i
\]

検証は
\[
  e(g_1, \sigma_{\mathrm{agg}}) \stackrel{?}{=} e(pk_{\mathrm{agg}}, H(m))
  \quad (= e(g_1, H(m))^{\sum x_i})
\]

**ポイント**: 多数の署名を「1本のペアリング検証＋公開鍵の加算」に近い形で確認でき、PoS のような “同じ投票内容に多人数が署名” する状況で非常に強いです。

#### 4.1.1 なぜ “足すだけ” で集約できるの？

鍵の中身を思い出すと、各署名は
\[
\sigma_i = x_i H(m)
\]
なので、足し合わせると
\[
\sigma_{\mathrm{agg}} = \sum_i \sigma_i = \sum_i x_i H(m) = \left(\sum_i x_i\right) H(m)
\]
になります。

一方で公開鍵も
\[
pk_i = x_i g_1,\quad pk_{\mathrm{agg}} = \sum_i pk_i = \left(\sum_i x_i\right)g_1
\]

つまり、「秘密鍵を足したのと同じ効果」が、**署名と公開鍵の“足し算”だけで表現できる**のが肝です。

#### 4.1.2 集約したときの検証式を、ペアリングで丁寧に導出

あなたが書いた（カンマ省略の形）
`e(pk_agg H(m)) = e(g1, σ_agg)`
は、ペアリングの引数が2つ必要なので、厳密には

\[
e(pk_{\mathrm{agg}}, H(m)) = e(g_1, \sigma_{\mathrm{agg}})
\]

という意味だと解釈します（カンマが省略されがちです）。

ここでは、このノートの流儀（\(pk \in G_1\), \(\sigma \in G_2\)）で、しかも **全員が同じメッセージ \(m\)** に署名するケースを扱います。

各参加者 \(i\) について
\[
pk_i = x_i g_1,\quad \sigma_i = x_i H(m)
\]

集約の定義：
\[
pk_{\mathrm{agg}} = \sum_{i=1}^n pk_i,\quad \sigma_{\mathrm{agg}} = \sum_{i=1}^n \sigma_i
\]

まず右辺から：
\[
e(g_1, \sigma_{\mathrm{agg}})
 = e\left(g_1, \sum_{i=1}^n \sigma_i\right)
\]
ペアリングは（加法表記では）第二引数の足し算に対して積に分解できます：
\[
e\left(g_1, \sum_{i=1}^n \sigma_i\right)
 = \prod_{i=1}^n e(g_1, \sigma_i)
\]
各 \(\sigma_i = x_iH(m)\) を代入して：
\[
\prod_{i=1}^n e(g_1, x_iH(m))
 = \prod_{i=1}^n e(g_1, H(m))^{x_i}
 = e(g_1, H(m))^{\sum_{i=1}^n x_i}
\]

次に左辺：
\[
e(pk_{\mathrm{agg}}, H(m))
 = e\left(\sum_{i=1}^n pk_i, H(m)\right)
\]
第一引数の足し算に対しても同様に積に分解できて：
\[
e\left(\sum_{i=1}^n pk_i, H(m)\right)
 = \prod_{i=1}^n e(pk_i, H(m))
\]
各 \(pk_i = x_ig_1\) を代入して：
\[
\prod_{i=1}^n e(x_ig_1, H(m))
 = \prod_{i=1}^n e(g_1, H(m))^{x_i}
 = e(g_1, H(m))^{\sum_{i=1}^n x_i}
\]

左右とも **同じ値 \(e(g_1, H(m))^{\sum x_i}\)** になるので、
\[
e(pk_{\mathrm{agg}}, H(m)) = e(g_1, \sigma_{\mathrm{agg}})
\]
が成り立ちます。

### 4.2 異なるメッセージに対する集約（一般の aggregate）

署名者ごとにメッセージが異なる \(m_i\) でも、署名の単純加算
\[
  \sigma_{\mathrm{agg}} = \sum_{i=1}^n x_i H(m_i)
\]
に対し、検証は（概念的に）
\[
  e(g_1, \sigma_{\mathrm{agg}})
  \stackrel{?}{=}
  \prod_{i=1}^n e(pk_i, H(m_i))
\]

この形は「多項積」になり、同一メッセージの場合ほど単純ではありませんが、それでも “多数署名を1本にまとめる” 価値は大きいです。

---

## 5. セキュリティ上の注意点：Rogue-Key 攻撃と PoP（Proof of Possession）

### 5.1 Rogue-Key 攻撃（ざっくり）

異なる公開鍵 \(pk_i\) を集約する仕組みでは、悪意ある参加者が
他人の公開鍵に依存して自分の公開鍵を細工し、「自分は署名していないのに集約検証を通す」
ような攻撃が問題になります（一般に rogue-key と呼ばれます）。

### 5.2 Ethereum PoS がやる対策（概念）

代表的な対策は **PoP（Proof of Possession）** で、
「その公開鍵に対応する秘密鍵を本当に持っている」ことを登録時に証明させます。

概念的には、例えば
- 登録時に固定メッセージ（または公開鍵自身）へ署名させて検証する  
などで、公開鍵の“なりすまし・細工”を防ぎ、集約署名を安全に扱えるようにします。

Ethereum PoS で “大量のバリデータ鍵を集約して扱える” 前提は、こうした仕組みで支えられています。

---

## 6. Ethereum PoS のどこで BLS が効くのか（イメージ）

Beacon Chain では、スロット/エポックごとに大量のバリデータが署名します。

- **Attestation**: 多数のバリデータが「同じ投票内容（同じ attestation data）」に署名し、集約してブロックに載せる  
- **Sync Committee**: 軽量クライアント向けに多数署名を集約して配布する  
- **Block proposer の署名**: ブロック提案にも署名が必要

この “大量署名” を扱うプロトコルにおいて、BLS の集約可能性がそのままスケーリング上の武器になります。

---

## 7. まとめ（超短縮）

- **BLS**はペアリングの双線形性により、検証が
  \[
    e(g_1, \sigma) = e(pk, H(m))
  \]
  という形になり、さらに **署名の加算＝集約** が自然にできる。  
- **Ethereum PoS が BLS を選ぶ主理由**は、attestation / sync committee などの “多人数同時署名” を **集約して小さく・速く扱う** ため。

---

## 8. Zcash プロトコル（zk-SNARK）文脈での説明：BLS12-381 と「modulo \(q\)」

Zcash（特に Groth16 などの zk-SNARK を用いる部分）では、ペアリングに **BLS12-381** を使います。ここで混乱しがちなのが、**「座標を割る法（基礎体）」**と**「スカラーを割る法（スカラー体）」**が別物、という点です。

### 8.1 何が「modulo \(q\)」なのか

Zcash 実装の慣習では、基礎体（Base field）を \( \mathbb{F}_q \) と書くことが多く、ここでの \(q\) は **381-bit の素数**です。

- \( \mathbb{F}_q \) 上の要素（曲線点の **座標 \(x,y\)** など）は **modulo \(q\)** で扱われる
- 一方、点のスカラー倍に使うスカラー（秘密鍵など）はスカラー体 \( \mathbb{F}_r \)（modulo \(r\)）側

#### 8.1.1 「\(a\) が 115 桁」とはどういう意味？

論文や仕様で \(a\) と書かれているものが何を指すかは文脈次第ですが、少なくとも

- \(a \in \mathbb{F}_q\) と書いてあるなら、\(a\) は **mod \(q\)** の世界の数

という意味です。つまり **0〜\(q-1\)** のどれかで、10進表記すると最大で 115 桁級になります。

ここで重要なのは「115 桁そのものが意味を持つ」のではなく、**“その巨大な素数 \(q\) を法にした世界の要素として扱う”**という点です。

### 8.2 「115 桁の数字」＝基礎体の法 \(q\)（BLS12-381 の \( \mathbb{F}_q \)）

BLS12-381 の基礎体の法 \(q\) は、10進でだいたい **115 桁**の巨大素数です（381 bit \(\approx 10^{114.6}\)）。

実際に使われる \(q\) は次の値です：

\[
\begin{aligned}
q &=
4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
\end{aligned}
\]

したがって、Zcash 文脈で「\(a\) を modulo \(q\) で計算する」「\(a \in \mathbb{F}_q\)」と言ったとき、\(a\) は
\[
0 \le a < q
\]
を満たす整数（の同値類）として表現でき、10進で最大 115 桁級になります。

#### 8.2.1 “mod \(q\)” の手触り（小さい例で）

巨大な \(q\) だと実感が湧きにくいので、**mod 7** の例で感覚を掴みます。

- \(a = 10\) を mod 7 の世界に持ち込むと \(a \equiv 3 \pmod 7\)
- \(b = 20\) は \(b \equiv 6 \pmod 7\)
- 足すと \((10+20) \equiv (3+6) \equiv 2 \pmod 7\)

実際の Zcash/BLS12-381 は **mod 7 の代わりに mod \(q\)** をやっているだけで、やっている計算の種類（足す/掛ける/逆数を取る）は同じです。

#### 8.2.2 Ethereum でよく見る `0x1a0111ea397fe69...` は何？

Ethereum の BLS（BLS12-381）を調べていると、次のような **16進数**が頻出します：

- 例（基礎体の法 \(q\) の16進表記）:  
  `0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab`

この数字が表しているものは、とてもシンプルに言うと：

- **「座標を計算する世界 \( \mathbb{F}_q \) の“法（ルールの基準になる素数）”」**

です。

もう少し丁寧に言うと、BLS12-381 の \(G_1\) を定義する曲線
\[
y^2 = x^3 + 4
\]
は、普通の整数の世界ではなく、**有限体 \( \mathbb{F}_q \) の上**で考えます。つまり実際には
\[
y^2 \equiv x^3 + 4 \pmod q
\]
という意味になります。

そしてここでの \(q\) を **10進で書くと 115 桁級**、**16進で書くと `0x...`** になります。

重要なのは「16進か10進か」は表記の違いに過ぎず、

- 10進で書いた \(q\)（このノートの上の節にある巨大な10進数）
- 16進で書いた \(q\)（`0x1a0111ea...aaab`）

は **同じ数**を表している、という点です。

なお、あなたが書いた `0x1a011ea397fe69...` は途中省略だと思いますが、先頭が似ているので上の \(q\) を指している可能性が高いです（途中の `11` が省略されている表記も見かけます）。

### 8.3 曲線方程式（Zcash でも Ethereum でも同じ BLS12-381）

（代表的な表現では）BLS12-381 の \(G_1\) は基礎体 \( \mathbb{F}_q \) 上の曲線
\[
E/\mathbb{F}_q:\quad y^2 = x^3 + 4
\]
の点（+ 無限遠点）からなります。ここで \(x,y\) はすべて **modulo \(q\)** です。

### 8.4 もう一つの法：スカラー体の法 \(r\)（署名の秘密鍵やスカラー倍）

秘密鍵 \(x\) やスカラー倍の係数は、通常スカラー体 \( \mathbb{F}_r \) の要素です。BLS12-381 の \(r\) は次の素数（約 77 桁）です：

\[
\begin{aligned}
r &=
52435875175126190479447740508185965837690552500527637822603658699938581184513
\end{aligned}
\]

16進数（Ethereum の資料でよく見る形）では次です：

- \(r\)（スカラー体の法）:  
  `0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001`

#### 8.4.1 ここが本題：\(q\) と \(r\) の関係は「役割が違う」

この2つは、どちらも巨大な素数ですが、**何を “mod” しているか（何の世界の法か）が違います**。

- **\(q\)**（基礎体の法）  
  - 曲線の点の **座標 \(x,y\)** を計算する世界の法  
  - つまり \(x,y\) は \(0 \le x,y < q\) の範囲の値として扱われ、演算はすべて mod \(q\)

- **\(r\)**（スカラー体の法 = 暗号で使う位数）  
  - “点を何回足したか” を表す **係数（スカラー）** の世界の法  
  - 秘密鍵 \(x\) は mod \(r\) の世界（\(\mathbb{F}_r\)）の要素

言い換えると：

- **\(q\)** は「座標を置くマス目（盤面）の大きさ」
- **\(r\)** は「暗号で使う“ループの長さ（点の巡回の長さ）”」

です。

#### 8.4.2 なぜ秘密鍵は \(1\)〜\(r-1\) から選ぶの？

秘密鍵はスカラーなので、本質的には
\[
x \in \{0,1,2,\dots,r-1\}
\]
（= \(\mathbb{F}_r\)）から選ぶのですが、**0だけは避けます**。理由はシンプルで、

- 公開鍵 \(pk = xg_1\) において、\(x=0\) だと \(pk = 0\)（無限遠点）になってしまう
- 署名 \(\sigma = xH(m)\) も \(x=0\) だと \(\sigma = 0\) になってしまう

からです（暗号として意味がなくなります）。

なので実装・仕様では通常
\[
1 \le x \le r-1
\]
の一様ランダムとして秘密鍵を取ります。

ちなみに \(r-1\) は mod \(r\) の世界では \(-1\) と同じで、
\[
r-1 \equiv -1 \pmod r
\]
という “普通の剰余の性質” そのものです。

#### 8.4.3 もう一段だけ：なぜ「位数（order）」が \(r\) なの？

暗号で使う \(G_1, G_2\) は「楕円曲線上の点全部」ではなく、その中の **素数位数 \(r\) の部分群**です。

生成元 \(g_1\) をその部分群から取ると、
\[
r g_1 = 0
\]
（\(g_1\) を \(r\) 回足すと元に戻る、という意味）になります。

だからスカラー倍 \(xg_1\) は **\(x\) を mod \(r\) で考えれば十分**で、秘密鍵も mod \(r\) の世界（\(\mathbb{F}_r\)）で扱うのが自然です。

つまり、同じ「BLS12-381」を使っていても

- 座標計算: \(x,y\) は **mod \(q\)**（\(\mathbb{F}_q\)）
- 鍵やスカラー: \(x\) は **mod \(r\)**（\(\mathbb{F}_r\)）

という二層構造になります。

### 8.5 Ethereum PoS とのつながり

Ethereum PoS の BLS 署名も同じ BLS12-381（同じ \(q,r\)）の上で動きます。違いは「それを何に使うか」で、Zcash は主に **証明（pairing を使う zk-SNARK 検証）**、Ethereum PoS は主に **多数署名の集約（aggregate）** に重心があります。


